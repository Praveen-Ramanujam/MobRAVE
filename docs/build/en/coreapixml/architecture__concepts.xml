<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.6.3">
  <compounddef id="architecture__concepts" kind="page">
    <compoundname>architecture_concepts</compoundname>
    <title>Introduction to the OpenRAVE Architecture</title>
    <detaileddescription>
<sect1 id="architecture__concepts_1fundamental_structure">
<title>Fundamental Structure</title>
<para><image type="html" name="openrave_architecture.png">OpenRAVE architecture</image>
</para><para><image type="latex" name="openrave_architecture.pdf" width="15cm">OpenRAVE architecture</image>
</para><para>OpenRAVE is divided in four main components as shown in the above figure:</para><para><itemizedlist>
<listitem><para><bold>Core Layer</bold> The core is composed of a set of <ref refid="group__interfaces" kindref="compound">Base Interface Classes</ref> defining how plugins share information, and it provides an environment interface that maintains a world state, which serves as the gateway to all functions offered through OpenRAVE. The global openrave state manages the loaded plugins, multiple independent environments, and logging. On the other hand, the <ref refid="classOpenRAVE_1_1EnvironmentBase" kindref="compound">environment</ref> combines collision checkers, viewers, physics engines, the kinematic world, and all its interfaces into a coherent robotics world state.</para></listitem></itemizedlist>
</para><para><itemizedlist>
<listitem><para><bold>Plugins Layer</bold> OpenRAVE is designed as a plugin-based architecture where a plugin offers implementations of the <ref refid="group__interfaces" kindref="compound">Base Interface Classes</ref> that are loaded dynamically into the <ref refid="classOpenRAVE_1_1EnvironmentBase" kindref="compound">environment</ref>. Plugins can be linked with other robotics libraries allowing <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> to expand its functionality, or it can offer <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> services to another robotics system. During startup, OpenRAVE parses the <ulink url="../main/environment_variables.html">OPENRAVE_PLUGINS</ulink> environment variable and loads all the plugins it finds.<itemizedlist>
<listitem><para>Refer to <ref refid="writing__plugins" kindref="compound">Writing Plugins and Interfaces</ref> for a tutorial on how to build and compile plugins.</para></listitem><listitem><para>Refer to <ref refid="interface__concepts" kindref="compound">Base Interface Concepts</ref> for interface details.</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para><para><itemizedlist>
<listitem><para><bold>Scripting Layer</bold> OpenRAVE provides scripting environments for <ulink url="http://openrave.org/en/main/tutorials/openravepy_beginning.html#openravepy-beginning">Python</ulink> and <ulink url="http://openrave.org/wiki/index.php/OctaveMATLAB">Octave/Matlab</ulink>. Python communicates with the core layer directly with in-memory calls, making it extremely fast. On the other hand, the Octave/Matlab scripting protocol send commands through TCP/IP, with a plugin offering a text server on the OpenRAVE core side. Scripting allows real-time modifications to any aspect of the environment without requiring shutdown, making it ideal to testing new algorithms. The Python scripting is so powerful, that most of the OpenRAVE examples and demo code are offered through it. In fact, users should treat the scripting language as an integral part of the entire system, not as a replacement to the C++ API.</para></listitem></itemizedlist>
</para><para><itemizedlist>
<listitem><para><bold>Robot Database Layer</bold> Implements a planning knowledge-base and provides simple interfaces for its access and generation parameters. The database itself mostly consists of kinematic, quasi-static, dynamic, and geometric analyses of the robot and the task. If the robot is defined properly, then all these functions should work out of the box.</para></listitem></itemizedlist>
</para><para>All the base planners and modules should be applicable to any robot structure that can be thrown at it. One of OpenRAVE&apos;s strongest points when compared with other planning packages is the idea of being able to apply algorithms in openrave to any robot, with very little modification. Recently, a planning database structure has been introduced that allows computation of properties like convex hull decomposition, grasp sets, reachability maps, analytic inverse kinematics, etc. If the robot is defined properly, then all these functions should work out of the box.</para><para>The main API is coded in C++ using the Boost C++ libraries [Dawes et al (1998- present)] as a really solid basis of low-level management and storage structures. The Boost flavors of shared pointers allow object pointers to be safely reference counted in a heavily multi-threaded environment. Shared pointers also allow handles and interfaces to be passed to the user without having to every worry about the user calling upon invalid objects or un- loaded shared objects. Furthermore, <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> uses functors and other abstracted objects commonly seen in higher level languages to specify function pointers for sampling distri- butions, event callbacks, setting robot configuration state, etc. The Boost-enabled design makes the the C++ API really safe and reliable to use along with saving the users a lot of trouble doing bookkeeping on their end. Furthermore, it allows the Resource Acquisition Is Initialization (RAII) design pattern [Stroustrup (2001)] to be fully exploited allowing users to ignore the complexities of multi-threaded resource management.</para></sect1>
<sect1 id="architecture__concepts_1arch_environment">
<title>Environment Concepts</title>
<para>All of OpenRAVE&apos;s services are offered through the environment. For example, requesting a planner interface called &apos;BiRRT&apos; is done through <ref refid="namespaceOpenRAVE_1a917047ebc086703b4eaf0bffd6ac9527" kindref="member">RaveCreatePlanner()</ref>. The environment supports:</para><para><itemizedlist>
<listitem><para><ref refid="namespaceOpenRAVE_1global_functionality" kindref="member">managing and communicating with plugins</ref></para></listitem><listitem><para><ref refid="classOpenRAVE_1_1EnvironmentBase_1env_collision_checking" kindref="member">collision checking</ref></para></listitem><listitem><para><ref refid="classOpenRAVE_1_1EnvironmentBase_1env_loading" kindref="member">loading scenes and objects</ref></para></listitem><listitem><para><ref refid="classOpenRAVE_1_1EnvironmentBase_1env_objects" kindref="member">managing objects and triangulation</ref></para></listitem><listitem><para><ref refid="classOpenRAVE_1_1EnvironmentBase_1env_plotting" kindref="member">drawing/plotting</ref></para></listitem></itemizedlist>
</para><para>Whenever objects in the environment are written or read, the user has to <bold>lock</bold> the environment mutex mutex GetMutex(). This prevents any other process from modifying the enviornment while the user is working. Because the environment uses &apos;recursive mutexes, it allows a mutex to be locked as many times as needed within the same thread. This has allowed all environment functions that require locking to always guarantee the mutex is locked, regardless if the user has locked the mutex. (Note that this only applies to environment functions, and not interface functions).</para><sect2 id="architecture__concepts_1arch_locking">
<title>Locking</title>
<para>Because OpenRAVE is a highly multi-threaded environment, the environment state like bodies and loaded interfaces could be simultaneously accessed. In order to safely write or read the state, a user has to lock the environment, which prevents any other process from modifying the environment while the user is working. By using recursive locks, it allows a lock to be locked as many times as needed within the same thread, greatly reducing the lock management when a state changing function calls another state changing function. This safety measure helps users by always guaranteeing the environment is locked when calling global level environment functions like creating new bodies or loading scenes, regardless if the user has locked it. However, directly accessing the bodies and robots is dangerous without having the environment lock acquired.</para></sect2>
<sect2 id="architecture__concepts_1arch_simulation">
<title>Simulation Thread</title>
<para>Every environment has an internal time and a simulation thread directly attached to a physics engine. The thread is always running in the background and periodically steps the simulation time by a small delta for the physics engine and on all the simulation-enabled interfaces. By default, the thread is always running and can always potentially modify the environment state; therefore, users always need to explicitly lock the environment whenever playing with the internal state like modifying bodies by setting joint values or link transformations. If not careful, the controller or physics engine will overwrite them. By default, the simulation thread just sets the object positions depending on their controller inputs, but a physics engine can be attached to integrate velocities, accelerations, forces, and torques.</para><para>The simulation thread can feel like a nuisance at first, but its division of robot control into control input computation and execution greatly helps users only concentrate on feeding commands to the robot without worrying about the simulation loop. It also allows a world update to happen in one one discrete time step.</para></sect2>
<sect2 id="architecture__concepts_1arch_cloning">
<title>Cloning</title>
<para>One of the strengths of OpenRAVE is in allowing multiple <ref refid="classOpenRAVE_1_1EnvironmentBase" kindref="compound">environments</ref> work simultaneously in the same process. Environment cloning allows OpenRAVE to become truly parallel by managing multiple environments and running simultaneous planners on top of them.</para><para>One of the strengths of <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> is in allowing multiple environments to work simul- taneously in the same process. Environment cloning allows <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> to become truly parallel by managing multiple environments and running simultaneous planners on top of them. Because there is no shared state across the clone and the original environment, it is not possible to use an interface created from one environment in another For example, if a planner is created in one environment, it should be used only by objects in that environment. It is not possible to set a planner to plan for objects belonging to a different environment. This is because a planner will lock the environment and expect the objects it controls to be exclusively under its control.</para><para>Creating a clone is simple, in C++ just type:</para><para><programlisting><codeline><highlight class="normal"><ref refid="namespaceOpenRAVE_1a652cd59d4cc9e3262d85e6776ec8ff9b" kindref="member">EnvironmentBasePtr</ref><sp/>pNewEnvironment<sp/>=<sp/>GetEnv()-&gt;CloneSelf(<ref refid="namespaceOpenRAVE_1a16bea31a72c441a002538eac01a118f2a0c49bf8f6cc2b8f1731b1aa8326c5e63" kindref="member" tooltip="clone all the bodies/robots of the environment, exclude attached interfaces like...">Clone_Bodies</ref>)</highlight></codeline>
</programlisting></para><para>to create a clone that copies all the existing bodies (with attachments and grabbed bodies) and their current states. Basically the clone can perform any operations that would have been done with the original enviornment.</para><para>Because the environment state is very complex, the cloning process can control how much of it gets transferred to the new clone. For example, all existing bodies and robots can be cloned, their attached controllers can be cloned, the attached viewer can be cloned, the collision checker state can be cloned, and the simulation state can be cloned. Basically the clone should be able to perform any operations that can be done with the original environment without any modification in the input parameters.</para><para>When cloning real robots, one extremely important feature that <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> cloning offers is the ability to maintain a real-time view of the world that sensors continuously update with new information. When a planner is instantiated, it should make a copy of the environment that it can exclusively control without interfering with the updating operations. Furthermore, the real-world environment possibly has robot controllers connected to real robots, having a clone gives the ability to set simulation controllers guarantees robot safety while planning; commands from a cloned environment would not accidentally send commands to the real robot.</para></sect2>
<sect2 id="architecture__concepts_1arch_validating_plugins">
<title>Validating Plugins</title>
<para>Every plugin needs to export several functions to notify the core what interfaces it has and to instantiate the interfaces. When a plugin is first loaded, it is validated by the environment and its interface information is queried so the core can register the names.</para><para>There are many mechanisms in the validation process to prevent old plugins to be loaded by the core. <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> is updated frequently and all user plugins are not necessarily recompiled when the <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> API changes. Therefore, we will encounter many cases when a plugin exports the correct functions, but does not implement the correct API. Using interfaces from plugins compiled with a mismatching The API can lead to unexpected crashes that are very difficult to debug, so it is absolutely necessary to detect this condition. One possible solution is to add version numbers to the API to enforce checking before an interface is returned from the plugin to the environment, but this method is brittle. It forces to keep track of a version number for every interface along with a global version number. Furthermore, every developer has to remember to increment the version when something even small changes, which can be easily forgotten and lead to serious errors later on.</para><para>We solve interface validation by computing a unique hash of the interface functions and members by running each interface through a C++ lexer, gathering the tokens that affect the C++ code structure, and then creating a 128bit unique MD5 hash. We create a hash for each interface definition and the environment. The hashes are hard coded into the C++ header files and can be queried by two methods: a static function returning the hash of the program calling the function, and a virtual function returning the hash the interface was compiled with. An interface is only valid if its virtual hash is equivalent to the static hash of the core environment. For a plugin to be loaded correctly, first the environment hashes have to match. If they do, then the individual interfaces checked and only matching interfaces are returned to the core, and from there dispatched to other plugins. Such consistency checks ensure that stale plugins will never be loaded.</para></sect2>
<sect2 id="architecture__concepts_1arch_cloning_parallel">
<title>Parallel Execution</title>
<para>Being able to execute a planner in multiple threads is important for applications that require speed and solution quality Because there is always a trade-off between solution quality and time of computation, some applications like industrial robots require the quickest and smoothest past to their destinations. Fortunately, environment cloning allows planners to create an independent environment for every thread they create, which enables them to call kinematics and collision functions in each respective thread without worrying about data corruption. Growing an RRT tree in a multi-threaded environment just requires one copy of the kd-tree structure to be maintained. The query operations mostly work with Euclidean distance on the configuration space, so are really fast. Furthermore, adding a new point takes O(log) time, so it shouldn’t be a bottleneck in the search process compared to collision checking. Finally, environment locking allows threads to gain exclusive access to the environment. The rule of thumb is that any interface belonging or added to the environment requires an environment lock before any of its methods can be called.</para></sect2>
</sect1>
<sect1 id="architecture__concepts_1arch_dualnature">
<title>Dual Simulation/Control Nature</title>
<para><ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> can be simultaneously used as a simulation, a controller, or both at the same time. Here are a couple of things to keep in mind:</para><para><itemizedlist>
<listitem><para>It can be used as a simulator by attaching a physics engine and setting torques to the joints and applying forces to the links.</para></listitem></itemizedlist>
</para><para><itemizedlist>
<listitem><para>The physics engine directly reflects the internal openrave state.</para></listitem></itemizedlist>
</para><para><itemizedlist>
<listitem><para>A controller can be set that sets torques/velocities/positions to the physics engine every time step. Physics simulation time steps are constantly called in an internal &quot;openrave thread&quot; if simulations are set to true (default)</para></listitem></itemizedlist>
</para><para><itemizedlist>
<listitem><para>The default physics engine doesn&apos;t touch the openrave state, nor does it simulate velocities or dynamics</para></listitem></itemizedlist>
</para><para><itemizedlist>
<listitem><para>The default controller just sets positions at the specified times</para></listitem></itemizedlist>
</para><para>This is why users need to explicitly lock the environment mutex whenever playing with the internal openrave state like setting joint values or link transformations (in planners for example). Otherwise, the controller or physics engine will overwrite them.</para></sect1>
<sect1 id="architecture__concepts_1arch_exceptions">
<title>Exception Handling</title>
<para>By using the C++ Standard and Boost libraries, <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> can recover from almost all errors that a user can experience without causing the program to shutdown on the spot. Invalid pointer and out-of-range accesses are extremely dangerous because they can modify unrelated memory, which causes the program to crash at a place completely unrelated to the root cause of the problem. Avoiding such problems has been one of the the highest priorities for the design. The core always surrounds any user code coming from plugins and callbacks with try/catch blocks, this allows the core to properly handle the error and notify the user of a problem without tearing down the environment. Because exception handling is slow, there is a fine balance of when a function should return an error code and what it should throw an exception. In <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref>, exceptions should never occur in normal operation of the program, they should only be for unexpected events of the program. For example, planners failing is an expected event dependent on the current environment, so planners should return an error code with the cause of the failure rather than throw an exception. In other words, exceptions convey the structural errors of the program that point to places in the code that should be fixed by the user. The following operations should throw exceptions in <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref>:</para><para><itemizedlist>
<listitem><para>invalid plugin or interface hashes,</para></listitem><listitem><para>invalid commands being sent to interfaces,</para></listitem><listitem><para>invalid arguments passed to functions,</para></listitem><listitem><para>invalid pointers or out-of-range parts of lists are accessed,</para></listitem><listitem><para>environment is not locked when it should be</para></listitem><listitem><para>a resource is present when it should be,</para></listitem><listitem><para>a math operation is not consistent with the rest of the environment,</para></listitem><listitem><para>environment naming constraints are not maintained,</para></listitem><listitem><para>unrecognized enumerated types are given, and</para></listitem><listitem><para>instantiation order is not maintained.</para></listitem></itemizedlist>
</para><para>Any type of boost error, or null pointer access throws an openrave_exception. This greatly reduces the amount of error checking code people do. For example, C code usually has this pattern:</para><para><programlisting><codeline><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>somefun(<ref refid="namespaceOpenRAVE_1abdcbe7a0abc56f7fd090dbd298a5a44c" kindref="member">KinBodyPtr</ref><sp/>pbody)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>!pbody<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pbody-&gt;GetTransform();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>or</para><para><programlisting><codeline><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>somefun(<ref refid="namespaceOpenRAVE_1abdcbe7a0abc56f7fd090dbd298a5a44c" kindref="member">KinBodyPtr</ref><sp/>pbody)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>!!pbody<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pbody-&gt;GetTransform();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>If these checks are not done, the code would segfault. However, these checks can really clutter the code. In openrave, it is safe to get away with:</para><para><programlisting><codeline><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>somefun(<ref refid="namespaceOpenRAVE_1abdcbe7a0abc56f7fd090dbd298a5a44c" kindref="member">KinBodyPtr</ref><sp/>pbody)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pbody-&gt;GetTransform();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>then for handling errors (for example in the most top-level script), do</para><para><programlisting><codeline><highlight class="keywordflow">try</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>somefun(pbody)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal">(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>openrave_exception&amp;<sp/>ex)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="openrave_8h_1a9bbbf668aa39f398c341e946ab8a43f5" kindref="member">RAVELOG_WARN</ref>(</highlight><highlight class="stringliteral">&quot;exception<sp/>caught:<sp/>%s\n&quot;</highlight><highlight class="normal">,ex.what());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>ex.GetCode()<sp/>==<sp/><ref refid="namespaceOpenRAVE_1adf2fa050995e80f643f8eddc14d7262cac10e4c55e82ea2bbb5b2028a4bf4e3cb" kindref="member">ORE_EnvironmentNotLocked</ref><sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="openrave_8h_1a9bbbf668aa39f398c341e946ab8a43f5" kindref="member">RAVELOG_WARN</ref>(</highlight><highlight class="stringliteral">&quot;user<sp/>forgot<sp/>to<sp/>lock<sp/>environment!\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>When using openravepy in python, such unhandled C++ errors throw a python exception, which can be safely caught and processed there.</para></sect1>
<sect1 id="architecture__concepts_1arch_body_hashes">
<title>Hashes for Body Structure</title>
<para>A new concept that came out of <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> is the idea of creating unique hashes of a body’s structure. Every body has an online state that includes:</para><para><itemizedlist>
<listitem><para>names of the body, its links, its joints,</para></listitem><listitem><para>link transformations, velocities, and accelerations in the world,</para></listitem><listitem><para>and attached bodies.</para></listitem></itemizedlist>
</para><para>All other information is independent of the environment and can be categorized into the kinematics, geometry, and dynamics of the body. Furthermore, robots have categories for attached sensors and manipulators. The planning knowledge-base stores all cached information about a body and a robot, so it needs an consistent way of indexing this information. Indexing by robot names is not reliable because it is very difficult to remind a user to change the name every time the body structure is changed. Therefore, <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> provides functionality to serialize the different categories of a body and create a 128-bit MD5 hash. Each of the models in the planning knowledge-base relies on different categories of the robot. For example:</para><para><itemizedlist>
<listitem><para>inverse kinematics generation only uses the kinematics of a sub-chain of the robot defined by the manipulator and the grasp coordinate system,</para></listitem><listitem><para>kinematic reachability cares about the robot geometry of the manipulator because it implicitly stores self-collision results,</para></listitem><listitem><para>inverse reachability further uses the links connecting the base robot link to the base manipulator link,</para></listitem><listitem><para>grasping cares about the geometry of the target body and the kinematics and geometry of the gripper,</para></listitem><listitem><para>convex decompositions only care about the link geometry, and</para></listitem><listitem><para>inverse dynamics cares only about the dynamics properties of each link and the kinematics.</para></listitem></itemizedlist>
</para><para>There are several challenges to developing a consistent index across all operating systems and compilers since floating point errors could creep in when normalizing floating-point values. However, the idea of such an index could greatly help in developing a worldwide robot database that anyone can use.</para></sect1>
<sect1 id="architecture__concepts_1supported_formats">
<title>Resource File Formats</title>
<para><ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> defines its own <ulink url="http://openrave.org/wiki/index.php/Format:XML">OpenRAVE XML</ulink> format that allows instantiation of any <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> interface and quick builing of robots and and kinematics structures. The rigid body geometries resources can be specified in virtually any 3D file format. For example:</para><para><itemizedlist>
<listitem><para>iv, vrml, wrl, stl, blend, 3ds, ase, obj, ply, dxf, lwo, lxo, ac, ms3d, x, mesh.xml, irrmesh, irr, nff, off, raw</para></listitem></itemizedlist>
</para><para>These files can be used inside the &lt;geom&gt; tags, or can be read directly into any of the environment ReadRobotX and ReadKinBodyX methods to create a single world body.</para><para><ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> also supports the <ulink url="http://www.collada.org">COLLADA</ulink> international standard on 3D geometry and modeling. COLLADA is augmented with these <ulink url="http://openrave.programmingvision.com/wiki/index.php/Format:COLLADA">OpenRAVE robot-specific extensions</ulink>.</para><para><ulink url="../main/robots_overview.html#file-formats">More information here.</ulink> </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
