<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.6.3">
  <compounddef id="arch__planner" kind="page">
    <compoundname>arch_planner</compoundname>
    <title>Planner Concepts</title>
    <detaileddescription>
<para><bold>Reference:</bold> <ref refid="classOpenRAVE_1_1PlannerBase" kindref="compound">OpenRAVE::PlannerBase</ref></para><sect1 id="arch__planner_1planner_intro">
<title>Introduction</title>
<para>In <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref>, the basic purpose of a planner is to find a trajectory starting at some initial configuration that reaches a goal condition while satisfying various navigation constraints. All planners are assumed to be geometric in nature (ie, not planning in the space of policies that depend on sensor data). Planners can have any configuration space defined by using the <ref refid="classOpenRAVE_1_1PlannerBase_1_1PlannerParameters" kindref="compound">OpenRAVE::PlannerBase::PlannerParameters</ref> structure. A planner should never use the raw joint values functions defined in KinBody.</para><para>The usage of a planner is simple:</para><para><itemizedlist>
<listitem><para>Acquire its pointer from RaveCreatePlanner.</para></listitem></itemizedlist>
</para><para><itemizedlist>
<listitem><para>Fill a <ref refid="classOpenRAVE_1_1PlannerBase_1_1PlannerParameters" kindref="compound">PlannerParameters</ref> structure defining the instance of the problem. The structure has many fields for describing planning entities like start position, goal condition, and the distance metric. Try to use these fields as much as possible. Later on, this will allow users to easily swap planners without having to change the PlannerBase::PlannerParameters structure much.</para></listitem></itemizedlist>
</para><para><itemizedlist>
<listitem><para>Call <ref refid="classOpenRAVE_1_1PlannerBase_1a109c37d3de7ee99f93c740a2df0e5e34" kindref="member">InitPlan</ref> passing in the robot and planner parameters. This also resets any previous information the planner had stored.</para></listitem></itemizedlist>
</para><para><itemizedlist>
<listitem><para>Call <ref refid="classOpenRAVE_1_1PlannerBase_1a7ce22311b1f81ec6b9bacdf457d4631a" kindref="member">PlanPath</ref> passing in a <ref refid="classOpenRAVE_1_1TrajectoryBase" kindref="compound">trajectory</ref> (and optionally an output stream) to start planning. If the function returns true, then the Trajectory will be filled with the geometric solution in the active DOF configuration space of the robot. By calling SetParameters, then PlanPath again, it could be possible to preserve the previous search space for the planner while changing the goal conditions.</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="arch__planner_1planner_planning">
<title>Planning Details</title>
<sect2 id="arch__planner_1planner_parameters">
<title>Planner Parameters - Calling a Planner</title>
<para>All the information defining a planning problem should be specified in PlannerBase::PlannerParameters. <computeroutput>PlannerParameters</computeroutput> tries to cover most of the common data like distance metrics, sampling distributions, initial and goal configurations. However there are many different types of inputs to a planner, so it is impossible to cover everything with one class. Instead, <computeroutput>PlannerParameters</computeroutput> has a very flexible and safe way to extend its parameters without destroying compatibility with a particular planner or user of the planner. This is enabled by the serialization to XML capabilities of <computeroutput>PlannerParameters</computeroutput></para><para><programlisting><codeline><highlight class="normal">PlannerBase::PlannerParametersPtr<sp/>params(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>PlannerBase::PlannerParameters());</highlight></codeline>
<codeline><highlight class="normal">params-&gt;vinitialconfig.push_back(2);</highlight></codeline>
<codeline><highlight class="normal">ostream<sp/>os;</highlight></codeline>
<codeline><highlight class="normal">os<sp/>&lt;&lt;<sp/>*params;</highlight></codeline>
</programlisting></para><para>will produce something in the form of <verbatim>
&lt;PlannerParameters&gt;
  &lt;initialconfig&gt;2&lt;/initialconfig&gt;
&lt;/PlannerParameters&gt;
</verbatim></para><para>Furthermore <ref refid="classOpenRAVE_1_1PlannerBase_1_1PlannerParameters" kindref="compound">PlannerParameters</ref> can read such an XML file given an input stream <verbatim>
istream is;
is &gt;&gt; *params;
</verbatim></para><para>Using XML as a medium, it is easy to exchange data across different derivations of <ref refid="classOpenRAVE_1_1PlannerBase_1_1PlannerParameters" kindref="compound">PlannerParameters</ref> without much effort. To add new parameters for planners to take advantage of</para><para><itemizedlist>
<listitem><para>make a derived class from <ref refid="classOpenRAVE_1_1PlannerBase_1_1PlannerParameters" kindref="compound">PlannerParameters</ref></para></listitem><listitem><para>overload the <ref refid="classOpenRAVE_1_1PlannerBase_1_1PlannerParameters_1a2084222cd1b9f555406d306d65680d7b" kindref="member">PlannerParameters</ref>, <ref refid="classOpenRAVE_1_1PlannerBase_1_1PlannerParameters_1aeef176e516fa467c3a1ea9c210f96d48" kindref="member">startElement</ref>, <ref refid="classOpenRAVE_1_1PlannerBase_1_1PlannerParameters_1afc6f1ff707e6fd690100c89e3cd4c291" kindref="member">endElement</ref>, and <ref refid="classOpenRAVE_1_1PlannerBase_1_1PlannerParameters_1a91544148bc143140fe0474224180233d" kindref="member">characters</ref> functions to process the new variables.</para></listitem></itemizedlist>
</para><para>As long as the user of the planner passes a <computeroutput>PlannerParameters</computeroutput> that can serialize to the same format of data that the planner expects, the data will be passed. This allows the planner and the caller of <ref refid="classOpenRAVE_1_1PlannerBase_1a7ce22311b1f81ec6b9bacdf457d4631a" kindref="member">PlanPath</ref> to use different <computeroutput>PlannerParameters</computeroutput>. definitions without any conflicts.</para></sect2>
<sect2 id="arch__planner_1planner_basicusage">
<title>Basic Usage</title>
<para>This is a simple call to a birrt planner, let <bold>activegoal</bold> hold the goal configuration and <bold>activejoints</bold> hold indices to the robot joints interested to plan for.</para><para><programlisting><codeline><highlight class="normal">PlannerBase::PlannerParametersPtr<sp/>params(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>PlannerBase::PlannerParameters);</highlight></codeline>
<codeline><highlight class="normal">params-&gt;SetRobotActiveJoints(robot);<sp/></highlight><highlight class="comment">//<sp/>sets<sp/>the<sp/>active<sp/>joint<sp/>indices<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">robot-&gt;GetActiveDOFValues(params.vinitialconfig);<sp/></highlight><highlight class="comment">//<sp/>set<sp/>initial<sp/>config<sp/>(use<sp/>current<sp/>robot<sp/>configuration)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">params.vgoalconfig<sp/>=<sp/>activegoal;</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>set<sp/>other<sp/>params<sp/>values<sp/>like</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceOpenRAVE_1ab39121477d2dd841859e79f112b52a0b" kindref="member">PlannerBasePtr</ref><sp/>rrtplanner<sp/>=<sp/><ref refid="namespaceOpenRAVE_1a917047ebc086703b4eaf0bffd6ac9527" kindref="member">RaveCreatePlanner</ref>(GetEnv(),</highlight><highlight class="stringliteral">&quot;rBiRRT&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceOpenRAVE_1aa3c159b394f2e4ec46ac49416a2acf17" kindref="member">TrajectoryBasePtr</ref><sp/>ptraj<sp/>=<sp/><ref refid="namespaceOpenRAVE_1aa987900651248eee02dc1ce6647dc543" kindref="member" tooltip="Return an empty trajectory instance.">RaveCreateTrajectory</ref>(GetEnv(),robot-&gt;GetActiveDOF());</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>!rrtplanner-&gt;InitPlan(robot,<sp/>params)<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceOpenRAVE_1a7cead738b92cbe2f332dea20dd2f200e" kindref="member" tooltip="the status of the PlanPath method. Used when PlanPath can be called multiple times...">PlannerStatus</ref><sp/>status<sp/>=<sp/>rrtplanner-&gt;Plan(ptraj);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>status<sp/>&amp;<sp/><ref refid="namespaceOpenRAVE_1a7cead738b92cbe2f332dea20dd2f200ea23c3ecb52bc33b330da0f5a4441115e5" kindref="member" tooltip="planner succeeded">PS_HasSolution</ref><sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>robot-&gt;SetActiveMotion(ptraj);<sp/></highlight><highlight class="comment">//<sp/>trajectory<sp/>is<sp/>done,<sp/>execute<sp/>on<sp/>the<sp/>robot</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>In order to speed up computations further, planners can use the CO_ActiveDOFs collision checker option, which only focuses collision on the currently moving links in the robot. If using the robot active DOF, before calling the planner, the user should insert this statement:</para><para><programlisting><codeline><highlight class="normal">CollisionOptionsStateSaver<sp/>optionstate(GetEnv()-&gt;GetCollisionChecker(),GetEnv()-&gt;GetCollisionChecker()-&gt;GetCollisionOptions()|<ref refid="namespaceOpenRAVE_1a6963e4ecb981351b8fb2e3f9e85acf77a95a75683a1fcadcd3de27e6465d74552" kindref="member">CO_ActiveDOFs</ref>,</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="arch__planner_1planner_extraparameters">
<title>Defining Extra Planner Parameters</title>
<para>Here is how to derive from a <ref refid="classOpenRAVE_1_1PlannerBase_1_1PlannerParameters" kindref="compound">PlannerParameters</ref> class in order to introduce new parameters.</para><para><programlisting><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">BasicRRTParameters<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>PlannerBase::PlannerParameters</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal">BasicRRTParameters()<sp/>:<sp/>_fGoalBiasProb(0.05f),<sp/>_bProcessing(false)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_vXMLParameters.push_back(</highlight><highlight class="stringliteral">&quot;goalbias&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespaceOpenRAVE_1a973ec569e405922437be98473d2aa6f8" kindref="member">dReal</ref><sp/>_fGoalBiasProb;<sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">protected</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>_bProcessing;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>serialize(std::ostream&amp;<sp/>O)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>!PlannerParameters::serialize(O)<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>O<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;&lt;goalbias&gt;&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>_fGoalBiasProb<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;&lt;/goalbias&gt;&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!!O;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ProcessElement<sp/>startElement(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>name,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::list&lt;std::pair&lt;std::string,std::string&gt;<sp/>&gt;&amp;<sp/>atts)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>_bProcessing<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>PE_Ignore;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal">(<sp/>PlannerBase::PlannerParameters::startElement(name,atts)<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>PE_Pass:<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>PE_Support:<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>PE_Support;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>PE_Ignore:<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>PE_Ignore;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_bProcessing<sp/>=<sp/>name==</highlight><highlight class="stringliteral">&quot;goalbias&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>_bProcessing<sp/>?<sp/>PE_Support<sp/>:<sp/>PE_Pass;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>endElement(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal">&amp;<sp/>name)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>_bProcessing<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>name<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;goalbias&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_ss<sp/>&gt;&gt;<sp/>_fGoalBiasProb;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="openrave_8h_1a9bbbf668aa39f398c341e946ab8a43f5" kindref="member">RAVELOG_WARN</ref>(str(boost::format(</highlight><highlight class="stringliteral">&quot;unknown<sp/>tag<sp/>%s\n&quot;</highlight><highlight class="normal">)%name));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_bProcessing<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>give<sp/>a<sp/>chance<sp/>for<sp/>the<sp/>default<sp/>parameters<sp/>to<sp/>get<sp/>processed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>PlannerParameters::endElement(name);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="arch__planner_1planner_development">
<title>Planner Development</title>
<para>Most planners do their computation iteratively, and they take lots of computation time. It is very frequent for a user to want to early-terminate the planner, or tell it to return the best solution it has founds immediately. Users might also want to visualize the planning process without getting into the internals of the planner. In order to do this, <ref refid="namespaceOpenRAVE" kindref="compound">OpenRAVE</ref> allows users to register callbacks via <ref refid="classOpenRAVE_1_1PlannerBase_1a7b72116e4770d98f2a78297246a679e8" kindref="member">OpenRAVE::PlannerBase::RegisterPlanCallback</ref>. Planner developers should <bold>always</bold> call <ref refid="classOpenRAVE_1_1PlannerBase_1a4b980a3cc0e8fc7abd2d0afe472ef695" kindref="member">OpenRAVE::PlannerBase::_CallCallbacks</ref> inside their planning loop and process the input correctly.</para></sect2>
</sect1>
<sect1 id="arch__planner_1planner_examples">
<title>Planner Examples</title>
<para>Examples of planners are:<itemizedlist>
<listitem><para>Manipulation - manipulable objects need to be specified. Objects like doors should be special cases that planners knows about.</para></listitem><listitem><para>Following - Goal easily changes. Attributes can change.</para></listitem><listitem><para>Path Smoothing - uses the input trajectory</para></listitem><listitem><para>Trajectory Re-timing - uses the input trajectory</para></listitem><listitem><para>Object Building - Need to describe how parts of object fit together into a bigger part.</para></listitem><listitem><para>Dish Washing - Specific goals are not specified, just a condition that all plates need to be inside.</para></listitem><listitem><para>Foot step planning - Need discrete footsteps and other capabilities from robot.</para></listitem></itemizedlist>
</para><para>Planner should be able to query sensor information from the Robot like its current camera image etc. Planner should be compatible with Robot presented; some hand-shaking should happen between the two during InitPlan function.</para></sect1>
<sect1 id="arch__planner_1planner_pathoptimization">
<title>Path Optimization</title>
<para>Path smoothing/optimization can be regarded as a post-processing step to planners. &quot;Path optimization&quot; algorithms take in an existing trajectory and filter it using the existing constraints of the planner. In fact, functionality there is no difference between a &quot;path optimization&quot; planner and a regular planner besides the fact that a trajectory is used as input. Because PlannerBase::PlanPath already has a trajectory as an argument, this does not cause any major API changes to the infrastructure.</para><para>However, the PlannerParameters structure had to reflect what &apos;path optimization&apos; algorithm to use for post processing the trajectory. This is now reflected in the PlannerParameters::_sPostProcessingPlanner and PlannerParameters::_sPostProcessingParameters arguments. By default, this is the default &quot;linear shortcut&quot; path optimizer. There is also a helper function in PlannerBase to help users easily call the post-processing step:</para><para><programlisting><codeline><highlight class="normal">_ProcessPostPlanners(<ref refid="namespaceOpenRAVE_1a5a9955dc6058f09c4462952478dfcf58" kindref="member">RobotBasePtr</ref><sp/>probot,<sp/><ref refid="namespaceOpenRAVE_1aa3c159b394f2e4ec46ac49416a2acf17" kindref="member">TrajectoryBasePtr</ref><sp/>ptraj);</highlight></codeline>
</programlisting></para><para>Please take a look at how the default RRT algorithms are now structured.</para><para>Planner post-processing actually allows users to chain planners in the same way that filters are chained, all through specifying planner parameters. Of course, users can continue to smooth in planners without relying on this framework. However, explicit control of path smoothing allows custom parameter to be easily specified. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
