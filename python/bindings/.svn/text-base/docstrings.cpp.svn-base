// -*- coding: utf-8 -*-
// Copyright (C) 2006-2011 Rosen Diankov (rosen.diankov@gmail.com)
//
// This file is part of OpenRAVE.
// OpenRAVE is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
/// Auto-generated using build_openravepy_internal.py from ../python/bindings/openravepy_int.cpp file
#include "docstrings.h"
namespace openravepy {
void InitializeComments(std::map<std::string,std::string>& m)
{m["en function InterfaceBase SendCommand"] = "\n\nbool  **SendCommand**\\(std::ostream & os, std::istream & is)\n    \n    Used to send special commands to the interface and receive output.\n    \n    The command must be registered by RegisterCommand. A special command ' is always supported and provides a way for the user to query the current commands and the help string. The format of the returned help commands are in reStructuredText. The following commands are possible:\n    *Parameters*\n     ``is`` - \n      the input stream containing the command \n     ``os`` - \n      the output stream containing the output \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if the command is not supported.\n    \n    *Return*\n        true if the command is successfully processed, otherwise false. \n        ";
m["en function InterfaceBase GetInterfaceType"] = "\n\nInterfaceType  **GetInterfaceType**\\()\n    \n            ";
m["en function InterfaceBase GetXMLId"] = "\n\nconst std::string &  **GetXMLId**\\()\n    \n    set internally by RaveDatabase\n    \n    *Return*\n        the unique identifier that describes this class type, case is ignored should be the same id used to create the object \n        ";
m["en function InterfaceBase GetPluginName"] = "\n\nconst std::string &  **GetPluginName**\\()\n    \n    set internally by RaveDatabase\n    \n    *Return*\n        the pluginname this interface was loaded from \n        ";
m["en function InterfaceBase GetDescription"] = "\n\nconst std::string &  **GetDescription**\\()\n    \n    Documentation of the interface in reStructuredText format. See Documenting Interfaces.\n    \n            ";
m["en function InterfaceBase GetEnv"] = "\n\nEnvironmentBasePtr  **GetEnv**\\()\n    \n    *Return*\n        the environment that this interface is attached to \n        ";
m["en function InterfaceBase Clone"] = "\n\nvoid  **Clone**\\(InterfaceBaseConstPtr preference, int cloningoptions)\n    \n    Clone the contents of an interface to the current interface.\n    \n    *Parameters*\n     ``preference`` - \n      the interface whose information to clone \n     ``cloningoptions`` - \n      mask of CloningOptions \\ *Exceptions*\n     ``openrave_exception`` - \n      if command doesn't succeed\n    \n            ";
m["en function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["en function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["en function InterfaceBase GetUserData"] = "\n\nUserDataPtr  **GetUserData**\\()\n    \n    return the user custom data\n    \n            ";
m["en function EnvironmentBase Reset"] = "\n\nvoid  **Reset**\\()\n    \n    Resets all objects of the scene (preserves all problems, planners).\n    \n    Do not call inside a SimulationStep call         ";
m["en function EnvironmentBase Destroy"] = "\n\nvoid  **Destroy**\\()\n    \n    Releases all environment resources, should be always called when environment stops being used.\n    \n    Removing all environment pointer might not be enough to destroy the environment resources.         ";
m["en function EnvironmentBase CloneSelf"] = "\n\nEnvironmentBasePtr  **CloneSelf**\\(int options)\n    \n    Create and return a clone of the current environment.\n    \n    *Parameters*\n     ``options`` - \n      A set of CloningOptions describing what is actually cloned. Clones do not share any memory or resource between each other. or their parent making them ideal for performing separte planning experiments while keeping the parent environment unchanged. By default a clone only copies the collision checkers and physics engine. When bodies are cloned, the unique ids are preserved across environments (each body can be referenced with its id in both environments). The attached and grabbed bodies of each body/robot are also copied to the new environment.\n    \n    *Return*\n        An environment of the same type as this environment containing the copied information. \n        ";
m["en function EnvironmentBase SetCollisionChecker"] = "\n\nbool  **SetCollisionChecker**\\(CollisionCheckerBasePtr pchecker)\n    \n    set the global environment collision checker\n    \n            ";
m["en function EnvironmentBase GetCollisionChecker"] = "\n\nCollisionCheckerBasePtr  **GetCollisionChecker**\\()\n    \n            ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, KinBodyConstPtr pbody2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, KinBodyConstPtr pbody2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink1, KinBody::LinkConstPtr plink2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink1, KinBody::LinkConstPtr plink2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"const RAY; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"const RAY; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"const RAY; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"const RAY; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,CollisionReportPtr) \n        ";
m["en function EnvironmentBase Load"] = "\n\nbool  **Load**\\(const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from a file and adds all objects in the environment.\n    \n            ";
m["en function EnvironmentBase Load"] = "\n\nbool  **Load**\\(const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from a file and adds all objects in the environment.\n    \n            ";
m["en function EnvironmentBase LoadData"] = "\n\nbool  **LoadData**\\(const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from in-memory data and adds all objects in the environment.\n    \n            ";
m["en function EnvironmentBase LoadData"] = "\n\nbool  **LoadData**\\(const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from in-memory data and adds all objects in the environment.\n    \n            ";
m["en function EnvironmentBase Save"] = "\n\nvoid  **Save**\\(const std::string & filename, SelectionOptions options = SO_Everything , const std::string & selectname = \"\" )\n    \n    Saves a scene depending on the filename extension. Default is in COLLADA format.\n    \n    *Parameters*\n     ``filename`` - \n      the filename to save the results at \n     ``options`` - \n      controls what to save \n     ``selectname`` - \n      \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if failed to save anything\n    \n            ";
m["en function EnvironmentBase Save"] = "\n\nvoid  **Save**\\(const std::string & filename, SelectionOptions options = SO_Everything , const std::string & selectname = \"\" )\n    \n    Saves a scene depending on the filename extension. Default is in COLLADA format.\n    \n    *Parameters*\n     ``filename`` - \n      the filename to save the results at \n     ``options`` - \n      controls what to save \n     ``selectname`` - \n      \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if failed to save anything\n    \n            ";
m["en function EnvironmentBase ReadRobotURI \"const std::string\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(const std::string & filename)\n    \n    Creates a new robot from a file with no extra load options specified.\n    \n            ";
m["en function EnvironmentBase ReadRobotURI \"const std::string\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(const std::string & filename)\n    \n    Creates a new robot from a file with no extra load options specified.\n    \n            ";
m["en function EnvironmentBase ReadRobotURI \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(RobotBasePtr robot, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a robot from a resource file. The robot is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. \n            ";
m["en function EnvironmentBase ReadRobotURI \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(RobotBasePtr robot, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a robot from a resource file. The robot is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. \n            ";
m["en function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadKinBodyURI \"const std::string\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(const std::string & filename)\n    \n    Creates a new kinbody from an XML file with no extra load options specified.\n    \n            ";
m["en function EnvironmentBase ReadKinBodyURI \"const std::string\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(const std::string & filename)\n    \n    Creates a new kinbody from an XML file with no extra load options specified.\n    \n            ";
m["en function EnvironmentBase ReadKinBodyURI \"KinBody; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(KinBodyPtr body, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from a resource file. The body is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. \n            ";
m["en function EnvironmentBase ReadKinBodyURI \"KinBody; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(KinBodyPtr body, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from a resource file. The body is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. \n            ";
m["en function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["en function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["en function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["en function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["en function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["en function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["en function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["en function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["en function EnvironmentBase AddKinBody"] = "\n\nvoid  **AddKinBody**\\(KinBodyPtr body, bool bAnonymous = false )\n    \n    Add a body to the environment.\n    \n    *Parameters*\n     ``body`` - \n      the pointer to an initialized body \n     ``bAnonymous`` - \n      if true and there exists a body/robot with the same name, will make body's name unique \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if body is invalid or already added\n    \n            ";
m["en function EnvironmentBase AddKinBody"] = "\n\nvoid  **AddKinBody**\\(KinBodyPtr body, bool bAnonymous = false )\n    \n    Add a body to the environment.\n    \n    *Parameters*\n     ``body`` - \n      the pointer to an initialized body \n     ``bAnonymous`` - \n      if true and there exists a body/robot with the same name, will make body's name unique \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if body is invalid or already added\n    \n            ";
m["en function EnvironmentBase AddRobot"] = "\n\nvoid  **AddRobot**\\(RobotBasePtr robot, bool bAnonymous = false )\n    \n    add a robot to the environment\n    \n    *Parameters*\n     ``robot`` - \n      the pointer to an initialized robot \n     ``bAnonymous`` - \n      if true and there exists a body/robot with the same name, will make robot's name unique \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if robot is invalid or already added\n    \n            ";
m["en function EnvironmentBase AddRobot"] = "\n\nvoid  **AddRobot**\\(RobotBasePtr robot, bool bAnonymous = false )\n    \n    add a robot to the environment\n    \n    *Parameters*\n     ``robot`` - \n      the pointer to an initialized robot \n     ``bAnonymous`` - \n      if true and there exists a body/robot with the same name, will make robot's name unique \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if robot is invalid or already added\n    \n            ";
m["en function EnvironmentBase AddSensor"] = "\n\nvoid  **AddSensor**\\(SensorBasePtr sensor, bool bAnonymous = false )\n    \n    registers the sensor with the environment and turns its power on.\n    \n    *Parameters*\n     ``sensor`` - \n      the pointer to an initialized sensor \n     ``bAnonymous`` - \n      if true and there exists a sensor with the same name, will make sensor's name unique \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if sensor is invalid or already added\n    \n            ";
m["en function EnvironmentBase AddSensor"] = "\n\nvoid  **AddSensor**\\(SensorBasePtr sensor, bool bAnonymous = false )\n    \n    registers the sensor with the environment and turns its power on.\n    \n    *Parameters*\n     ``sensor`` - \n      the pointer to an initialized sensor \n     ``bAnonymous`` - \n      if true and there exists a sensor with the same name, will make sensor's name unique \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if sensor is invalid or already added\n    \n            ";
m["en function EnvironmentBase AddViewer"] = "\n\nvoid  **AddViewer**\\(ViewerBasePtr pviewer)\n    \n    adds a viewer to the environment\n    \n    *Exceptions*\n     ``openrave_exception`` - \n      Throw if body is invalid or already added \n            ";
m["en function EnvironmentBase RemoveKinBody"] = "\n\nbool  **RemoveKinBody**\\(KinBodyPtr body)\n    \n            ";
m["en function EnvironmentBase Remove"] = "\n\nbool  **Remove**\\(InterfaceBasePtr obj)\n    \n    Removes a currently loaded interface from the environment.\n    \n    *Parameters*\n     ``obj`` - \n      interface to remove The function removes currently loaded bodies, robots, sensors, problems from the actively used interfaces of the environment. This does not destroy the interface, but it does remove all references managed. Some interfaces like problems have destroy methods that are called to signal unloading. Note that the active interfaces are different from the owned interfaces.\n    \n    *Return*\n        true if the interface was successfully removed from the environment. \n        ";
m["en function EnvironmentBase GetKinBody"] = "\n\nKinBodyPtr  **GetKinBody**\\(const std::string & name)\n    \n    Query a body from its name.\n    \n    *Return*\n        first KinBody (including robots) that matches with name \n        ";
m["en function EnvironmentBase GetRobot"] = "\n\nRobotBasePtr  **GetRobot**\\(const std::string & name)\n    \n    Query a robot from its name.\n    \n    *Return*\n        first Robot that matches the name \n        ";
m["en function EnvironmentBase GetSensor"] = "\n\nSensorBasePtr  **GetSensor**\\(const std::string & name)\n    \n    Query a sensor from its name.\n    \n    *Return*\n        first sensor that matches with name, note that sensors attached to robots have the robot name as a prefix. \n        ";
m["en function EnvironmentBase GetBodyFromEnvironmentId"] = "\n\nKinBodyPtr  **GetBodyFromEnvironmentId**\\(int id)\n    \n    Get the corresponding body from its unique network id.\n    \n            ";
m["en function EnvironmentBase AddModule"] = "\n\nint  **AddModule**\\(ModuleBasePtr module, const std::string & cmdargs)\n    \n    Load a new module, need to Lock if calling outside simulation thread.\n    \n            ";
m["en function EnvironmentBase AddModule"] = "\n\nint  **AddModule**\\(ModuleBasePtr module, const std::string & cmdargs)\n    \n    Load a new module, need to Lock if calling outside simulation thread.\n    \n            ";
m["en function EnvironmentBase RemoveProblem"] = "\n\nbool  **RemoveProblem**\\(ModuleBasePtr prob)\n    \n            ";
m["en function EnvironmentBase GetModules"] = "\n\nboost::shared_ptr< void >  **GetModules**\\(std::list<  ModuleBasePtr  > & listModules)\n    \n    Returns a list of loaded problems with a pointer to a lock preventing the list from being modified.\n    \n    As long as the lock is held, the problems are guaranteed to stay loaded in the environment.\n    \n    *Return*\n        returns a pointer to a Lock. Destroying the shared_ptr will release the lock \n        ";
m["en function EnvironmentBase GetModules"] = "\n\nboost::shared_ptr< void >  **GetModules**\\(std::list<  ModuleBasePtr  > & listModules)\n    \n    Returns a list of loaded problems with a pointer to a lock preventing the list from being modified.\n    \n    As long as the lock is held, the problems are guaranteed to stay loaded in the environment.\n    \n    *Return*\n        returns a pointer to a Lock. Destroying the shared_ptr will release the lock \n        ";
m["en function EnvironmentBase SetPhysicsEngine"] = "\n\nbool  **SetPhysicsEngine**\\(PhysicsEngineBasePtr physics)\n    \n    *Parameters*\n     ``physics`` - \n      the engine to set, if NULL, environment sets an dummy physics engine set the physics engine, disabled by default \n            ";
m["en function EnvironmentBase GetPhysicsEngine"] = "\n\nPhysicsEngineBasePtr  **GetPhysicsEngine**\\()\n    \n            ";
m["en function EnvironmentBase RegisterCollisionCallback"] = "\n\nboost::shared_ptr< void >  **RegisterCollisionCallback**\\(const  CollisionCallbackFn  & callback)\n    \n    Register a collision callback.Whenever a collision is detected between between bodies during a CheckCollision call or physics simulation, the callback is called. The callback should return an action specifying how the collision should be handled:\n    \n    *Return*\n        a handle to the registration, once the handle loses scope, the callback is unregistered \n        ";
m["en function EnvironmentBase StepSimulation"] = "\n\nvoid  **StepSimulation**\\(dReal timeStep)\n    \n    Makes one simulation time step.\n    \n    Can be called manually by the user inside planners. Keep in mind that the internal simulation thread also calls this function periodically. See Simulation Thread for more about the simulation thread.         ";
m["en function EnvironmentBase StartSimulation"] = "\n\nvoid  **StartSimulation**\\(dReal fDeltaTime, bool bRealTime = true )\n    \n    Start the internal simulation thread.\n    \n    Resets simulation time to 0. See Simulation Thread for more about the simulation thread.\\ *Parameters*\n     ``fDeltaTime`` - \n      the delta step to take in simulation \n     ``bRealTime`` - \n      if false will call SimulateStep as fast as possible, otherwise will time the simulate step calls so that simulation progresses with real system time. \n            ";
m["en function EnvironmentBase StopSimulation"] = "\n\nvoid  **StopSimulation**\\()\n    \n    Stops the internal physics loop, stops calling SimulateStep for all modules.\n    \n    See Simulation Thread for more about the simulation thread.         ";
m["en function EnvironmentBase GetSimulationTime"] = "\n\nuint64_t  **GetSimulationTime**\\()\n    \n    Return simulation time since the start of the environment (in microseconds).\n    \n    See Simulation Thread for more about the simulation thread.         ";
m["en function EnvironmentBase GetViewer"] = "\n\nViewerBasePtr  **GetViewer**\\(const std::string & name = \"\" )\n    \n    Return a viewer with a particular name.\n    \n    When no name is specified, the first loaded viewer is returned.         ";
m["en function EnvironmentBase drawlinestrip \"const float; int; int; float; const float\""] = "\n\nOpenRAVE::GraphHandlePtr  **drawlinestrip**\\(const float * ppoints, int numPoints, int stride, float fwidth, const float * colors)\n    \n    Draws a series of connected lines with individual colors.\n    \n    *Parameters*\n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride)\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawlinelist \"const float; int; int; float; const float\""] = "\n\nOpenRAVE::GraphHandlePtr  **drawlinelist**\\(const float * ppoints, int numPoints, int stride, float fwidth, const float * colors)\n    \n    Draws a list of individual lines, each specified by a succeeding pair of points.\n    \n    *Parameters*\n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride)\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawarrow"] = "\n\nOpenRAVE::GraphHandlePtr  **drawarrow**\\(const RaveVector< float > & p1, const RaveVector< float > & p2, float fwidth, const RaveVector< float > & color = RaveVector< float >(1, 0.5, 0.5, 1) )\n    \n    Draws an arrow p1 is start, p2 is finish.\n    \n    *Parameters*\n     ``color`` - \n      the rgb color of the point. The last component of the color is used for alpha blending.\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawbox"] = "\n\nOpenRAVE::GraphHandlePtr  **drawbox**\\(const RaveVector< float > & vpos, const RaveVector< float > & vextents)\n    \n    Draws a box.\n    \n    extents are half the width, height, and depth of the box\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawplane"] = "\n\nOpenRAVE::GraphHandlePtr  **drawplane**\\(const RaveTransform< float > & tplane, const RaveVector< float > & vextents, const boost::multi_array< float, 3 > & vtexture)\n    \n    Draws a textured plane.\n    \n    *Parameters*\n     ``tplane`` - \n      describes the center of the plane. the zaxis of this coordinate is the normal of the plane \n     ``vextents`` - \n      the extents of the plane along the x and y directions (z is ignored) \n     ``vtexture`` - \n      a 3D array specifying height x width x color (the color dimension can be 1, 3, or 4 (for alpha blending))\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawplane"] = "\n\nOpenRAVE::GraphHandlePtr  **drawplane**\\(const RaveTransform< float > & tplane, const RaveVector< float > & vextents, const boost::multi_array< float, 3 > & vtexture)\n    \n    Draws a textured plane.\n    \n    *Parameters*\n     ``tplane`` - \n      describes the center of the plane. the zaxis of this coordinate is the normal of the plane \n     ``vextents`` - \n      the extents of the plane along the x and y directions (z is ignored) \n     ``vtexture`` - \n      a 3D array specifying height x width x color (the color dimension can be 1, 3, or 4 (for alpha blending))\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawtrimesh \"const float; int; const int; int; const boost::multi_array\""] = "\n\nOpenRAVE::GraphHandlePtr  **drawtrimesh**\\(const float * ppoints, int stride, const int * pIndices, int numTriangles, const boost::multi_array< float, 2 > & colors)\n    \n    Draws a triangle mesh, each vertices of each triangle should be counter-clockwise.\n    \n    *Parameters*\n     ``ppoints`` - \n      - array of 3D points \n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride) \n     ``pIndices`` - \n      If not NULL, zero-based indices into the points for every triangle. pIndices should be of size numTriangles. If pIndices is NULL, ppoints is assumed to contain numTriangles*3 points and triangles will be rendered in list order. \n     ``color`` - \n      The color of the triangle. The last component of the color is used for alpha blending\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase GetRobots"] = "\n\nvoid  **GetRobots**\\(std::vector<  RobotBasePtr  > & robots)\n    \n    Fill an array with all robots loaded in the environment.\n    \n            ";
m["en function EnvironmentBase GetBodies"] = "\n\nvoid  **GetBodies**\\(std::vector<  KinBodyPtr  > & bodies)\n    \n    Get all bodies loaded in the environment (including robots).\n    \n    *Parameters*\n     ``bodies`` - \n      filled with all the bodies \n            ";
m["en function EnvironmentBase GetSensors"] = "\n\nvoid  **GetSensors**\\(std::vector<  SensorBasePtr  > & sensors)\n    \n    Fill an array with all sensors loaded in the environment.\n    \n    The sensors come from the currently loaded robots and the explicitly added sensors         ";
m["en function EnvironmentBase UpdatePublishedBodies"] = "\n\nvoid  **UpdatePublishedBodies**\\()\n    \n    updates the published bodies that viewers and other programs listening in on the environment see. For example, calling this function inside a planning loop allows the viewer to update the environment reflecting the status of the planner. Assumes that the physics are locked.         ";
m["en function EnvironmentBase Triangulate"] = "\n\nvoid  **Triangulate**\\(KinBody::Link::TRIMESH  & trimesh, KinBodyConstPtr pbody)\n    \n    Triangulation of the body including its current transformation. trimesh will be appended the new data.\n    \n    *Parameters*\n     ``trimesh`` - \n      - The output triangle mesh \n     ``body`` - \n      body the triangulate \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if failed to add anything\n    \n            ";
m["en function EnvironmentBase TriangulateScene"] = "\n\nvoid  **TriangulateScene**\\(KinBody::Link::TRIMESH  & trimesh, SelectionOptions options, const std::string & selectname)\n    \n    General triangulation of the whole scene.\n    \n    *Parameters*\n     ``trimesh`` - \n      - The output triangle mesh. The new triangles are appended to the existing triangles! \n     ``options`` - \n      - Controlls what to triangulate. \n     ``selectname`` - \n      - name of the body used in options \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if failed to add anything\n    \n            ";
m["en function EnvironmentBase SetDebugLevel"] = "\n\nvoid  **SetDebugLevel**\\(uint32_t level)\n    \n    *Parameters*\n     ``level`` - \n      0 for no debug, 1 - to print all debug messeges. Default value for release builds is 0, for debug builds it is 1 declaring variables with stdcall can be a little complex sets the debug level \n            ";
m["en function EnvironmentBase GetDebugLevel"] = "\n\nuint32_t  **GetDebugLevel**\\()\n    \n            ";
m["en function EnvironmentBase GetHomeDirectory"] = "\n\nconst std::string &  **GetHomeDirectory**\\()\n    \n            ";
m["en function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["en function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["en function InterfaceBase GetUserData"] = "\n\nUserDataPtr  **GetUserData**\\()\n    \n    return the user custom data\n    \n            ";
m["en function RaveGetEnvironmentId"] = "\n\nOPENRAVE_API int  **RaveGetEnvironmentId**\\(EnvironmentBasePtr penv)\n    \n    return the environment's unique id, returns 0 if environment could not be found or not registered\n    \n            ";
m["en function RaveGetEnvironment"] = "\n\nOPENRAVE_API  EnvironmentBasePtr  **RaveGetEnvironment**\\(int id)\n    \n    get the environment from its unique id\n    \n    *Parameters*\n     ``id`` - \n      the unique environment id returned by RaveGetEnvironmentId \n            ";
m["en function RaveGetEnvironments"] = "\n\nOPENRAVE_API void  **RaveGetEnvironments**\\(std::list<  EnvironmentBasePtr  > & listenvironments)\n    \n    Return all the created OpenRAVE environments.\n    \n            ";
m["en function RaveCreateInterface"] = "\n\nOPENRAVE_API  InterfaceBasePtr  **RaveCreateInterface**\\(EnvironmentBasePtr penv, InterfaceType type, const std::string & interfacename)\n    \n            ";
m["en enum SelectionOptions"] = "\n\n **SelectionOptions**\n    \n    A set of options used to select particular parts of the scene.\n    \n            ";
m["ja function InterfaceBase SendCommand"] = "\n\nbool  **SendCommand**\\(std::ostream & os, std::istream & is)\n    \n    Used to send special commands to the interface and receive output.\n    \n    The command must be registered by RegisterCommand. A special command ' is always supported and provides a way for the user to query the current commands and the help string. The format of the returned help commands are in reStructuredText. The following commands are possible:\n    *Parameters*\n     ``is`` - \n      the input stream containing the command \n     ``os`` - \n      the output stream containing the output \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if the command is not supported.\n    \n    *Return*\n        true if the command is successfully processed, otherwise false. \n        ";
m["ja function InterfaceBase GetInterfaceType"] = "\n\nInterfaceType  **GetInterfaceType**\\()\n    \n            ";
m["ja function InterfaceBase GetXMLId"] = "\n\nconst std::string &  **GetXMLId**\\()\n    \n    set internally by RaveDatabase\n    \n    *Return*\n        the unique identifier that describes this class type, case is ignored should be the same id used to create the object \n        ";
m["ja function InterfaceBase GetPluginName"] = "\n\nconst std::string &  **GetPluginName**\\()\n    \n    set internally by RaveDatabase\n    \n    *Return*\n        the pluginname this interface was loaded from \n        ";
m["ja function InterfaceBase GetDescription"] = "\n\nconst std::string &  **GetDescription**\\()\n    \n    Documentation of the interface in reStructuredText format. See Documenting Interfaces.\n    \n            ";
m["ja function InterfaceBase GetEnv"] = "\n\nEnvironmentBasePtr  **GetEnv**\\()\n    \n    *Return*\n        the environment that this interface is attached to \n        ";
m["ja function InterfaceBase Clone"] = "\n\nvoid  **Clone**\\(InterfaceBaseConstPtr preference, int cloningoptions)\n    \n    Clone the contents of an interface to the current interface.\n    \n    *Parameters*\n     ``preference`` - \n      the interface whose information to clone \n     ``cloningoptions`` - \n      mask of CloningOptions \\ *Exceptions*\n     ``openrave_exception`` - \n      if command doesn't succeed\n    \n            ";
m["ja function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["ja function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["ja function InterfaceBase GetUserData"] = "\n\nUserDataPtr  **GetUserData**\\()\n    \n    return the user custom data\n    \n            ";
m["ja function EnvironmentBase Reset"] = "\n\nvoid  **Reset**\\()\n    \n    Resets all objects of the scene (preserves all problems, planners).\n    \n    Do not call inside a SimulationStep call         ";
m["ja function EnvironmentBase Destroy"] = "\n\nvoid  **Destroy**\\()\n    \n    Releases all environment resources, should be always called when environment stops being used.\n    \n    Removing all environment pointer might not be enough to destroy the environment resources.         ";
m["ja function EnvironmentBase CloneSelf"] = "\n\nEnvironmentBasePtr  **CloneSelf**\\(int options)\n    \n    Create and return a clone of the current environment.\n    \n    *Parameters*\n     ``options`` - \n      A set of CloningOptions describing what is actually cloned. Clones do not share any memory or resource between each other. or their parent making them ideal for performing separte planning experiments while keeping the parent environment unchanged. By default a clone only copies the collision checkers and physics engine. When bodies are cloned, the unique ids are preserved across environments (each body can be referenced with its id in both environments). The attached and grabbed bodies of each body/robot are also copied to the new environment.\n    \n    *Return*\n        An environment of the same type as this environment containing the copied information. \n        ";
m["ja function EnvironmentBase SetCollisionChecker"] = "\n\nbool  **SetCollisionChecker**\\(CollisionCheckerBasePtr pchecker)\n    \n    set the global environment collision checker\n    \n            ";
m["ja function EnvironmentBase GetCollisionChecker"] = "\n\nCollisionCheckerBasePtr  **GetCollisionChecker**\\()\n    \n            ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, KinBodyConstPtr pbody2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, KinBodyConstPtr pbody2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink1, KinBody::LinkConstPtr plink2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink1, KinBody::LinkConstPtr plink2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"const RAY; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"const RAY; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"const RAY; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"const RAY; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase Load"] = "\n\nbool  **Load**\\(const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from a file and adds all objects in the environment.\n    \n            ";
m["ja function EnvironmentBase Load"] = "\n\nbool  **Load**\\(const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from a file and adds all objects in the environment.\n    \n            ";
m["ja function EnvironmentBase LoadData"] = "\n\nbool  **LoadData**\\(const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from in-memory data and adds all objects in the environment.\n    \n            ";
m["ja function EnvironmentBase LoadData"] = "\n\nbool  **LoadData**\\(const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from in-memory data and adds all objects in the environment.\n    \n            ";
m["ja function EnvironmentBase Save"] = "\n\nvoid  **Save**\\(const std::string & filename, SelectionOptions options = SO_Everything , const std::string & selectname = \"\" )\n    \n    Saves a scene depending on the filename extension. Default is in COLLADA format.\n    \n    *Parameters*\n     ``filename`` - \n      the filename to save the results at \n     ``options`` - \n      controls what to save \n     ``selectname`` - \n      \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if failed to save anything\n    \n            ";
m["ja function EnvironmentBase Save"] = "\n\nvoid  **Save**\\(const std::string & filename, SelectionOptions options = SO_Everything , const std::string & selectname = \"\" )\n    \n    Saves a scene depending on the filename extension. Default is in COLLADA format.\n    \n    *Parameters*\n     ``filename`` - \n      the filename to save the results at \n     ``options`` - \n      controls what to save \n     ``selectname`` - \n      \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if failed to save anything\n    \n            ";
m["ja function EnvironmentBase ReadRobotURI \"const std::string\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(const std::string & filename)\n    \n    Creates a new robot from a file with no extra load options specified.\n    \n            ";
m["ja function EnvironmentBase ReadRobotURI \"const std::string\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(const std::string & filename)\n    \n    Creates a new robot from a file with no extra load options specified.\n    \n            ";
m["ja function EnvironmentBase ReadRobotURI \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(RobotBasePtr robot, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a robot from a resource file. The robot is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. \n            ";
m["ja function EnvironmentBase ReadRobotURI \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(RobotBasePtr robot, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a robot from a resource file. The robot is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. \n            ";
m["ja function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadKinBodyURI \"const std::string\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(const std::string & filename)\n    \n    Creates a new kinbody from an XML file with no extra load options specified.\n    \n            ";
m["ja function EnvironmentBase ReadKinBodyURI \"const std::string\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(const std::string & filename)\n    \n    Creates a new kinbody from an XML file with no extra load options specified.\n    \n            ";
m["ja function EnvironmentBase ReadKinBodyURI \"KinBody; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(KinBodyPtr body, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from a resource file. The body is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. \n            ";
m["ja function EnvironmentBase ReadKinBodyURI \"KinBody; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(KinBodyPtr body, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from a resource file. The body is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. \n            ";
m["ja function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["ja function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["ja function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["ja function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["ja function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["ja function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["ja function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["ja function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["ja function EnvironmentBase AddKinBody"] = "\n\nvoid  **AddKinBody**\\(KinBodyPtr body, bool bAnonymous = false )\n    \n    Add a body to the environment.\n    \n    *Parameters*\n     ``body`` - \n      the pointer to an initialized body \n     ``bAnonymous`` - \n      if true and there exists a body/robot with the same name, will make body's name unique \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if body is invalid or already added\n    \n            ";
m["ja function EnvironmentBase AddKinBody"] = "\n\nvoid  **AddKinBody**\\(KinBodyPtr body, bool bAnonymous = false )\n    \n    Add a body to the environment.\n    \n    *Parameters*\n     ``body`` - \n      the pointer to an initialized body \n     ``bAnonymous`` - \n      if true and there exists a body/robot with the same name, will make body's name unique \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if body is invalid or already added\n    \n            ";
m["ja function EnvironmentBase AddRobot"] = "\n\nvoid  **AddRobot**\\(RobotBasePtr robot, bool bAnonymous = false )\n    \n    add a robot to the environment\n    \n    *Parameters*\n     ``robot`` - \n      the pointer to an initialized robot \n     ``bAnonymous`` - \n      if true and there exists a body/robot with the same name, will make robot's name unique \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if robot is invalid or already added\n    \n            ";
m["ja function EnvironmentBase AddRobot"] = "\n\nvoid  **AddRobot**\\(RobotBasePtr robot, bool bAnonymous = false )\n    \n    add a robot to the environment\n    \n    *Parameters*\n     ``robot`` - \n      the pointer to an initialized robot \n     ``bAnonymous`` - \n      if true and there exists a body/robot with the same name, will make robot's name unique \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if robot is invalid or already added\n    \n            ";
m["ja function EnvironmentBase AddSensor"] = "\n\nvoid  **AddSensor**\\(SensorBasePtr sensor, bool bAnonymous = false )\n    \n    registers the sensor with the environment and turns its power on.\n    \n    *Parameters*\n     ``sensor`` - \n      the pointer to an initialized sensor \n     ``bAnonymous`` - \n      if true and there exists a sensor with the same name, will make sensor's name unique \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if sensor is invalid or already added\n    \n            ";
m["ja function EnvironmentBase AddSensor"] = "\n\nvoid  **AddSensor**\\(SensorBasePtr sensor, bool bAnonymous = false )\n    \n    registers the sensor with the environment and turns its power on.\n    \n    *Parameters*\n     ``sensor`` - \n      the pointer to an initialized sensor \n     ``bAnonymous`` - \n      if true and there exists a sensor with the same name, will make sensor's name unique \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if sensor is invalid or already added\n    \n            ";
m["ja function EnvironmentBase AddViewer"] = "\n\nvoid  **AddViewer**\\(ViewerBasePtr pviewer)\n    \n    adds a viewer to the environment\n    \n    *Exceptions*\n     ``openrave_exception`` - \n      Throw if body is invalid or already added \n            ";
m["ja function EnvironmentBase RemoveKinBody"] = "\n\nbool  **RemoveKinBody**\\(KinBodyPtr body)\n    \n            ";
m["ja function EnvironmentBase Remove"] = "\n\nbool  **Remove**\\(InterfaceBasePtr obj)\n    \n    Removes a currently loaded interface from the environment.\n    \n    *Parameters*\n     ``obj`` - \n      interface to remove The function removes currently loaded bodies, robots, sensors, problems from the actively used interfaces of the environment. This does not destroy the interface, but it does remove all references managed. Some interfaces like problems have destroy methods that are called to signal unloading. Note that the active interfaces are different from the owned interfaces.\n    \n    *Return*\n        true if the interface was successfully removed from the environment. \n        ";
m["ja function EnvironmentBase GetKinBody"] = "\n\nKinBodyPtr  **GetKinBody**\\(const std::string & name)\n    \n    Query a body from its name.\n    \n    *Return*\n        first KinBody (including robots) that matches with name \n        ";
m["ja function EnvironmentBase GetRobot"] = "\n\nRobotBasePtr  **GetRobot**\\(const std::string & name)\n    \n    Query a robot from its name.\n    \n    *Return*\n        first Robot that matches the name \n        ";
m["ja function EnvironmentBase GetSensor"] = "\n\nSensorBasePtr  **GetSensor**\\(const std::string & name)\n    \n    Query a sensor from its name.\n    \n    *Return*\n        first sensor that matches with name, note that sensors attached to robots have the robot name as a prefix. \n        ";
m["ja function EnvironmentBase GetBodyFromEnvironmentId"] = "\n\nKinBodyPtr  **GetBodyFromEnvironmentId**\\(int id)\n    \n    Get the corresponding body from its unique network id.\n    \n            ";
m["ja function EnvironmentBase AddModule"] = "\n\nint  **AddModule**\\(ModuleBasePtr module, const std::string & cmdargs)\n    \n    Load a new module, need to Lock if calling outside simulation thread.\n    \n            ";
m["ja function EnvironmentBase AddModule"] = "\n\nint  **AddModule**\\(ModuleBasePtr module, const std::string & cmdargs)\n    \n    Load a new module, need to Lock if calling outside simulation thread.\n    \n            ";
m["ja function EnvironmentBase RemoveProblem"] = "\n\nbool  **RemoveProblem**\\(ModuleBasePtr prob)\n    \n            ";
m["ja function EnvironmentBase GetModules"] = "\n\nboost::shared_ptr< void >  **GetModules**\\(std::list<  ModuleBasePtr  > & listModules)\n    \n    Returns a list of loaded problems with a pointer to a lock preventing the list from being modified.\n    \n    As long as the lock is held, the problems are guaranteed to stay loaded in the environment.\n    \n    *Return*\n        returns a pointer to a Lock. Destroying the shared_ptr will release the lock \n        ";
m["ja function EnvironmentBase GetModules"] = "\n\nboost::shared_ptr< void >  **GetModules**\\(std::list<  ModuleBasePtr  > & listModules)\n    \n    Returns a list of loaded problems with a pointer to a lock preventing the list from being modified.\n    \n    As long as the lock is held, the problems are guaranteed to stay loaded in the environment.\n    \n    *Return*\n        returns a pointer to a Lock. Destroying the shared_ptr will release the lock \n        ";
m["ja function EnvironmentBase SetPhysicsEngine"] = "\n\nbool  **SetPhysicsEngine**\\(PhysicsEngineBasePtr physics)\n    \n    *Parameters*\n     ``physics`` - \n      the engine to set, if NULL, environment sets an dummy physics engine set the physics engine, disabled by default \n            ";
m["ja function EnvironmentBase GetPhysicsEngine"] = "\n\nPhysicsEngineBasePtr  **GetPhysicsEngine**\\()\n    \n            ";
m["ja function EnvironmentBase RegisterCollisionCallback"] = "\n\nboost::shared_ptr< void >  **RegisterCollisionCallback**\\(const  CollisionCallbackFn  & callback)\n    \n    Register a collision callback.Whenever a collision is detected between between bodies during a CheckCollision call or physics simulation, the callback is called. The callback should return an action specifying how the collision should be handled:\n    \n    *Return*\n        a handle to the registration, once the handle loses scope, the callback is unregistered \n        ";
m["ja function EnvironmentBase StepSimulation"] = "\n\nvoid  **StepSimulation**\\(dReal timeStep)\n    \n    Makes one simulation time step.\n    \n    Can be called manually by the user inside planners. Keep in mind that the internal simulation thread also calls this function periodically. See Simulation Thread for more about the simulation thread.         ";
m["ja function EnvironmentBase StartSimulation"] = "\n\nvoid  **StartSimulation**\\(dReal fDeltaTime, bool bRealTime = true )\n    \n    Start the internal simulation thread.\n    \n    Resets simulation time to 0. See Simulation Thread for more about the simulation thread.\\ *Parameters*\n     ``fDeltaTime`` - \n      the delta step to take in simulation \n     ``bRealTime`` - \n      if false will call SimulateStep as fast as possible, otherwise will time the simulate step calls so that simulation progresses with real system time. \n            ";
m["ja function EnvironmentBase StopSimulation"] = "\n\nvoid  **StopSimulation**\\()\n    \n    Stops the internal physics loop, stops calling SimulateStep for all modules.\n    \n    See Simulation Thread for more about the simulation thread.         ";
m["ja function EnvironmentBase GetSimulationTime"] = "\n\nuint64_t  **GetSimulationTime**\\()\n    \n    Return simulation time since the start of the environment (in microseconds).\n    \n    See Simulation Thread for more about the simulation thread.         ";
m["ja function EnvironmentBase GetViewer"] = "\n\nViewerBasePtr  **GetViewer**\\(const std::string & name = \"\" )\n    \n    Return a viewer with a particular name.\n    \n    When no name is specified, the first loaded viewer is returned.         ";
m["ja function EnvironmentBase drawlinestrip \"const float; int; int; float; const float\""] = "\n\nOpenRAVE::GraphHandlePtr  **drawlinestrip**\\(const float * ppoints, int numPoints, int stride, float fwidth, const float * colors)\n    \n    Draws a series of connected lines with individual colors.\n    \n    *Parameters*\n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride)\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawlinelist \"const float; int; int; float; const float\""] = "\n\nOpenRAVE::GraphHandlePtr  **drawlinelist**\\(const float * ppoints, int numPoints, int stride, float fwidth, const float * colors)\n    \n    Draws a list of individual lines, each specified by a succeeding pair of points.\n    \n    *Parameters*\n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride)\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawarrow"] = "\n\nOpenRAVE::GraphHandlePtr  **drawarrow**\\(const RaveVector< float > & p1, const RaveVector< float > & p2, float fwidth, const RaveVector< float > & color = RaveVector< float >(1, 0.5, 0.5, 1) )\n    \n    Draws an arrow p1 is start, p2 is finish.\n    \n    *Parameters*\n     ``color`` - \n      the rgb color of the point. The last component of the color is used for alpha blending.\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawbox"] = "\n\nOpenRAVE::GraphHandlePtr  **drawbox**\\(const RaveVector< float > & vpos, const RaveVector< float > & vextents)\n    \n    Draws a box.\n    \n    extents are half the width, height, and depth of the box\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawplane"] = "\n\nOpenRAVE::GraphHandlePtr  **drawplane**\\(const RaveTransform< float > & tplane, const RaveVector< float > & vextents, const boost::multi_array< float, 3 > & vtexture)\n    \n    Draws a textured plane.\n    \n    *Parameters*\n     ``tplane`` - \n      describes the center of the plane. the zaxis of this coordinate is the normal of the plane \n     ``vextents`` - \n      the extents of the plane along the x and y directions (z is ignored) \n     ``vtexture`` - \n      a 3D array specifying height x width x color (the color dimension can be 1, 3, or 4 (for alpha blending))\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawplane"] = "\n\nOpenRAVE::GraphHandlePtr  **drawplane**\\(const RaveTransform< float > & tplane, const RaveVector< float > & vextents, const boost::multi_array< float, 3 > & vtexture)\n    \n    Draws a textured plane.\n    \n    *Parameters*\n     ``tplane`` - \n      describes the center of the plane. the zaxis of this coordinate is the normal of the plane \n     ``vextents`` - \n      the extents of the plane along the x and y directions (z is ignored) \n     ``vtexture`` - \n      a 3D array specifying height x width x color (the color dimension can be 1, 3, or 4 (for alpha blending))\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawtrimesh \"const float; int; const int; int; const boost::multi_array\""] = "\n\nOpenRAVE::GraphHandlePtr  **drawtrimesh**\\(const float * ppoints, int stride, const int * pIndices, int numTriangles, const boost::multi_array< float, 2 > & colors)\n    \n    Draws a triangle mesh, each vertices of each triangle should be counter-clockwise.\n    \n    *Parameters*\n     ``ppoints`` - \n      - array of 3D points \n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride) \n     ``pIndices`` - \n      If not NULL, zero-based indices into the points for every triangle. pIndices should be of size numTriangles. If pIndices is NULL, ppoints is assumed to contain numTriangles*3 points and triangles will be rendered in list order. \n     ``color`` - \n      The color of the triangle. The last component of the color is used for alpha blending\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase GetRobots"] = "\n\nvoid  **GetRobots**\\(std::vector<  RobotBasePtr  > & robots)\n    \n    Fill an array with all robots loaded in the environment.\n    \n            ";
m["ja function EnvironmentBase GetBodies"] = "\n\nvoid  **GetBodies**\\(std::vector<  KinBodyPtr  > & bodies)\n    \n    Get all bodies loaded in the environment (including robots).\n    \n    *Parameters*\n     ``bodies`` - \n      filled with all the bodies \n            ";
m["ja function EnvironmentBase GetSensors"] = "\n\nvoid  **GetSensors**\\(std::vector<  SensorBasePtr  > & sensors)\n    \n    Fill an array with all sensors loaded in the environment.\n    \n    The sensors come from the currently loaded robots and the explicitly added sensors         ";
m["ja function EnvironmentBase UpdatePublishedBodies"] = "\n\nvoid  **UpdatePublishedBodies**\\()\n    \n    updates the published bodies that viewers and other programs listening in on the environment see. For example, calling this function inside a planning loop allows the viewer to update the environment reflecting the status of the planner. Assumes that the physics are locked.         ";
m["ja function EnvironmentBase Triangulate"] = "\n\nvoid  **Triangulate**\\(KinBody::Link::TRIMESH  & trimesh, KinBodyConstPtr pbody)\n    \n    Triangulation of the body including its current transformation. trimesh will be appended the new data.\n    \n    *Parameters*\n     ``trimesh`` - \n      - The output triangle mesh \n     ``body`` - \n      body the triangulate \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if failed to add anything\n    \n            ";
m["ja function EnvironmentBase TriangulateScene"] = "\n\nvoid  **TriangulateScene**\\(KinBody::Link::TRIMESH  & trimesh, SelectionOptions options, const std::string & selectname)\n    \n    General triangulation of the whole scene.\n    \n    *Parameters*\n     ``trimesh`` - \n      - The output triangle mesh. The new triangles are appended to the existing triangles! \n     ``options`` - \n      - Controlls what to triangulate. \n     ``selectname`` - \n      - name of the body used in options \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if failed to add anything\n    \n            ";
m["ja function EnvironmentBase SetDebugLevel"] = "\n\nvoid  **SetDebugLevel**\\(uint32_t level)\n    \n    *Parameters*\n     ``level`` - \n      0 for no debug, 1 - to print all debug messeges. Default value for release builds is 0, for debug builds it is 1 declaring variables with stdcall can be a little complex sets the debug level \n            ";
m["ja function EnvironmentBase GetDebugLevel"] = "\n\nuint32_t  **GetDebugLevel**\\()\n    \n            ";
m["ja function EnvironmentBase GetHomeDirectory"] = "\n\nconst std::string &  **GetHomeDirectory**\\()\n    \n            ";
m["ja function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["ja function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["ja function InterfaceBase GetUserData"] = "\n\nUserDataPtr  **GetUserData**\\()\n    \n    return the user custom data\n    \n            ";
m["ja function RaveGetEnvironmentId"] = "\n\nOPENRAVE_API int  **RaveGetEnvironmentId**\\(EnvironmentBasePtr penv)\n    \n    return the environment's unique id, returns 0 if environment could not be found or not registered\n    \n            ";
m["ja function RaveGetEnvironment"] = "\n\nOPENRAVE_API  EnvironmentBasePtr  **RaveGetEnvironment**\\(int id)\n    \n    get the environment from its unique id\n    \n    *Parameters*\n     ``id`` - \n      the unique environment id returned by RaveGetEnvironmentId \n            ";
m["ja function RaveGetEnvironments"] = "\n\nOPENRAVE_API void  **RaveGetEnvironments**\\(std::list<  EnvironmentBasePtr  > & listenvironments)\n    \n    Return all the created OpenRAVE environments.\n    \n            ";
m["ja function RaveCreateInterface"] = "\n\nOPENRAVE_API  InterfaceBasePtr  **RaveCreateInterface**\\(EnvironmentBasePtr penv, InterfaceType type, const std::string & interfacename)\n    \n            ";
m["ja enum SelectionOptions"] = "\n\n **SelectionOptions**\n    \n    A set of options used to select particular parts of the scene.\n    \n            ";

}
}
